% Copyright (c) 2011 Martin Ueding <dev@martin-ueding.de>
%
\documentclass[12pt]{article}
\usepackage{geometry}
\geometry{a4paper}
\usepackage{graphicx}
\usepackage{amssymb}
\usepackage{epstopdf}
\usepackage[utf8]{inputenc}
\usepackage[activate]{pdfcprot}
\usepackage{setspace}
\usepackage[ngerman]{babel}
\usepackage[parfill]{parskip}
\usepackage{hyperref}
\usepackage{color}
\definecolor{darkblue}{rgb}{0,0,.5}
\definecolor{lightblue}{rgb}{0.9,.9,1}
\definecolor{gray}{rgb}{.3,.3,.3}
\hypersetup{pdftex=true, colorlinks=true, breaklinks=false, linkcolor=black, menucolor=black, pagecolor=black, urlcolor=darkblue}
\DeclareGraphicsRule{.tif}{png}{.png}{`convert #1 `dirname #1`/`basename #1 .tif`.png}
\usepackage{bold-extra}
\usepackage{caption}
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox{gray}{\parbox{\textwidth}{#1#2#3}}}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white, margin=0pt, font={bf,footnotesize}}

\usepackage{listings}
\lstset{
	breaklines=true,
	showstringspaces=false,
%	backgroundcolor=\color{lightblue},
	framexleftmargin=0pt,
	framexrightmargin=0pt,
	framextopmargin=0pt,
	framexbottommargin=0pt,
	frame=b,
	xleftmargin=0pt,
	xrightmargin=0pt,
	basicstyle=\footnotesize\ttfamily,
	keywordstyle=\color{black}\bfseries,
	}

\newcommand\gqq[1]{\glqq #1\grqq}

\newcommand\dd[2]{\item[\texttt{#1}] #2}

\title{EDV für Physiker}
\author{Martin Ueding}

\begin{document}

\maketitle

\tableofcontents
\newpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                               Anfang Inhalte                                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Übung 1}

\subsection{Befehle in der Konsole}
\label{commands}

\begin{itemize}

\dd{apropos}{Unscharfe suche nach Befehlen.}
\dd{bc}{Einfacher Taschenrechner. Man sollte in der Bash allerdings nicht mit \texttt{\$(echo 5+4 | bc)} rechnen, sondern die neuen, von C übernommenen Funktionen zum direkten Rechnen, \texttt{\$((5+4))}, benutzen.}
\dd{bzip2}{Komprimiert eine Datei.}
\dd{cal}{Zeigt einen Kalendermonat an.}
\dd{cd}{Wechselt in das Verzeichnis \texttt{<dir>}. Dabei ist \texttt{..} das übergeordnete Verzeichnis. Wird als Verzeichnis \texttt{-} angegeben, kommt man in das vorherige Verzeichnis. \texttt{cd} ohne Verzeichnis wechselt in das Heimatverzeichnis\footnote{\texttt{$\sim$} oder meistens \texttt{/home/<benutzername>}.}}
\dd{chmod}{Ändert Dateirechte.}
\dd{clear}{Fügt leere Zeilen ein, bis der Bildschirm leer ist.}
\dd{cp}{Kopiert Dateien.}
\dd{date}{Zeigt das Datum in einem gewählten Format an.}
\dd{df}{Listet die Dateisysteme mit Belegungsangabe.}
\dd{diff}{Vergleicht Dateien miteinander.}
\dd{du}{Zeigt die Größe von Dateien auf dem Datenträger an. Diese muss nicht unbedingt mit der Größe überstimmen, die \texttt{ls} anzeigt, da die Dateien in Blöcken organisiert sind.}
\dd{echo}{Gibt Text aus.}
\dd{emacs}{Texteditor.}
\dd{find}{Führt eine Dateisystemtraverse nach speziellen Suchvorgaben durch und zeigt standardmäßig alle Dateien und Ordner an.}
\dd{grep}{Filtert Zeilen nach einem Suchmuster.}
\dd{gv}{Zeigt die PDF oder PS Datei \texttt{<datei>} an.}
\dd{gzip}{Komprimiert eine Datei.}
\dd{head}{Zeigt die ersten n Zeilen einer Datei an.}
\dd{history}{Zeigt die letzten Kommandos an.}
\dd{hostname}{Rechnername.}
\dd{last}{Letzte logins aller Benutzer.}
\dd{less}{Zeigt eine Datei an und erlaubt scrollen, suchen, springen. Es können viele Befehle aus \texttt{vi} (gg, G, /, j, k) benutzt werden.}
\dd{ls}{ Listet den Inhalt des Verzeichnises \texttt{<dir>} oder des aktuellen Verzeichnises aus. Dabei werden auch Informationen über Zugriffsrechte und Eigentümer, Größe und Änderungsdatum angezeigt.}
\dd{man}{Zeigt man pages an.}
\dd{mkdir}{Erstellt ein Verzeichnis \texttt{<dir>}.}
\dd{mv}{Verschiebt Dateien, Umbennen ist ein Spezialfall.}
\dd{ps}{Prozessliste.}
\dd{rmdir}{Löscht leere Verzeichnisse.}
\dd{rm}{Löscht Dateien.}
\dd{scp}{Kopiert über SSH.}
\dd{set}{Zeigt das Environment der Shell an.}
\dd{sort}{Sortiert Zeilen.}
\dd{ssh}{Öffnete eine Shell auf einem anderen Computer.}
\dd{tail}{Gegenstück zu \texttt{head}.}
\dd{tar}{Erstellt ein Archiv mehrerer Dateien. Mit \texttt{tar -xzf archiv.tar.gt datei1 datei2…} erstellt man direkt ein komprimiertes Archiv mehrerer Dateien.}
\dd{top}{Vorgänger von \texttt{htop}, ein Taskmanager.}
\dd{touch}{Setzt das Änderungsdatum einer Datei auf den aktuellen Zeitpunkt und erzeugt die Datei, falls sie nicht existiert.}
\dd{uname}{Kernelversion, Rechnername, ...}
\dd{uniq}{Spezialfall von \texttt{sort -u}}
\dd{uptime}{Zeigt, wie viele Nächte der Rechner am Stück durchgemacht hat.}
\dd{vim}{Texteditor für Programmierer.}
\dd{wc}{Zählt Wörter, Zeilen, Buchstaben.}
\dd{wget}{Lädt Dateien per http oder ftp.}
\dd{whatis}{Zeigt die erste Zeile der man page an.}
\dd{whoami}{Eigener Benutzername.}
\dd{w}{Wie \texttt{who}, nur ausführlicher.}
\end{itemize}

\subsection{absoluter und relativer Pfad}

Ein absoluter Pfad beginnt immer mit einem \texttt{/}, wie beispielsweise \\ \texttt{/home/mu/Dokumente/Studium/EDV/Bericht} oder \texttt{/dev/null}. Ein relativer Pfad bezieht sich immer auf ein aktuelles Arbeitsverzeichnis. Beispielsweise beschreibt \texttt{datei.tex} die Datei \texttt{/tmp/datei.txt}, falls der Benutzer gerade \texttt{/tmp} als Arbeitsverzeichnis hat. Pfade können auch \texttt{..} enthalten, dies bezeichnet das übergeordnete Verzeichnis. Ist man gerade in \texttt{/etc/apache2}, so kann man mit \texttt{../passwd} auf die zentrale Passwortdatei verweisen.

Gemeinerweise können absolute Pfade auch \texttt{..} enthalten, so wäre \\
\texttt{/etc/apache2/../passwd} ein legaler Pfad, sinnvoll ist es in vielen Fällen allerdings nicht.

\subsection{grundlegende Emacs Steuerung}

\begin{tabular}{ll}
Aktion & Tasten \\
\hline
Cursor links & C-b \\
Cursor rauf & C-p \\
Cursor rechts & C-f \\
Cursor runter & C-n \\
Datei speichern & C-x C-s \\
Emacs beenden & C-x C-c \\
Hilfe aufrufen & C-h t \\
Seite rauf & M-v \\
Seite runter & C-v \\
\end{tabular}

\section{Übung 2}

Neue Befehle sind in §\ref{commands} mit den Befehlen aus vorherigen Übungen zusammen.

\subsection{Das Unix-Hilfe-System -- der \texttt{man} Befehl}

Generell sollte jedes Programm eine man page haben, die genauso wie das Programm selbst heißt. So kann man mit \texttt{man programm} diese Seite aufrufen.

Bash Builtins haben keine solche Hilfeseite, sie werden mit \texttt{help command} dokumentiert, oder können in \texttt{bash.1} nachgeschaut werden.

Darüber hinaus gibt es noch die info Dokumente.

Meistens haben Programme auch noch eine eigene Hilfe dabei, die mit \texttt{programm -h} oder \texttt{programm --help} aufgerufen werden kann.

\subsection{Datums und Kalenderangaben}

\subsection{Bash Variablen}

Mit \texttt{echo \${HOME}} kann man das Heimatverzeichnis anzeigen lassen. Dabei ist \texttt{echo \$HOME} eine der vielen Environmentvariablen, die in der Bash gesetzt sind. Man kann sie mit \texttt{set} anschauen. \texttt{echo \${HOSTNAME}} enthält den Rechnernamen.

Mit den geschweiften Klammern kann man mehrere Wörter aus einem erzeugen, dies ist praktisch für das erstellen von Sicherungskopien: \verb#cp foo{,.bak}# erstellt eine Kopie der Datei \texttt{foo} nach \texttt{foo.bak}, ohne dass man foo zweimal schreiben muss.

Das Programm \texttt{cal} zeigt einen Kalendermonat an. Der September 1752 ist etwas anders, als die restlichen Monate, da hier in einigen, leider nicht allen, Ländern der Wechsel zwischen Kalendersystemen vollzogen worden ist.

\subsection{Umgang mit Dateien und Verzeichnissen}

Hier gibt es wenig zu beschreiben, man muss sein aktuelles Arbeitsverzeichnis im Auge behalten und beachten, dass \texttt{rmdir} nur leere Verzeichnisse löscht.

\subsection{Absolute und relative Pfade}

Auch hier muss man sein Arbeitsverzeichnis für die relativen Pfade im Kopf haben, ansonsten ist es alles recht logisch.

\subsection{Wildcards}

Die Dateien lassen sich recht einfach erstellen:
\begin{lstlisting}[caption=Anlegen der Dateien]
touch datei{1..9}.txt logfile{10,10a,11,11a,11b}.txt
\end{lstlisting}

Dann kann man die Datein mit folgenden Befehlen zeigen:
\lstinputlisting[caption=ls.sh]{../Uebung_02/wildcards/ls.sh}
\lstinputlisting[caption=Ausgabe von ls.sh]{../Uebung_02/wildcards/ls.sh.out}

Ich habe hier \texttt{echo} anstelle von \texttt{ls} benutzt, da die Wildcards so oder so von der Bash und nicht vom Befehl aufgelöst werden und \texttt{ls} jede Datei auf eine eigene Zeile schreibt, sofern STOUT kein Terminal ist.

\subsection{Umgang mit Rechten unter Unix}

Jede Datei hat drei grundlegende Rechte, lesen (r), schreiben (w) und ausführen (x). Darüber hinaus gibt es noch drei Kategorien: Eigentümer, Gruppe und Alle. Mit \texttt{chmod -w} entzieht man allen das Schreibrecht, auch sich selbst. Setzt man die Rechte auf \texttt{rw-r--r--}\footnote{mit \texttt{chmod 644}} darf nur der Eigentümer die Datei schreiben, alle sie aber lesen.

\section{Übung 3}

\subsection{Weitere Unix-Befehle}

Siehe §\ref{commands}.

\subsection{Eingabe- und Ausgabeumleitung}

Siehe \url{../Uebung_03/standardausgabe.txt}.

\subsection{Handling von Textdateien Dateien}

Siehe \url{../Uebung_03/Auto_out_D.txt}.

\subsection{Pipelines}

Siehe \url{../Uebung_03/zahlen_out.dat}.

\subsection{Komprimierung und Archivierung}

Leider war die Datei cc++.tar zum Bearbeitungszeitpunkt nicht verfügbar. So habe ich 55 MiB HTML Dateien zum Testen benutzt.

\begin{tabular}{llll}
Programm & Option & Zeit [s] & Dateigröße [KiB] \\
\hline
tar + bzip2 &  & 4.29 + 11.02 & 12701 \\
tar + bzip2 & -1 & 4.29 + 11.81 & 12701 \\
tar + bzip2 & -9 & 4.29 + 11.00 & 12701 \\
tar + gzip &  & 4.29 + 2.37 & 14149 \\
tar + gzip & -1 & 4.29 + 1.51 & 15514 \\
tar + gzip & -9 & 4.29 + 4.30 & 14073 \\
zip &  & 2.29 & 16694\\
\end{tabular}

Man sieht, dass bzip2 etwas besser komprimiert, allerdings deutlich länger braucht. Zip komprimiert lede Datei einzeln und kann so Passagen, die in mehreren Dateien vorkommen, nicht effizient komprimieren. Jedoch können einzelne Dateien aus dem Archiv genommen werden, bei einem komprimierten tar muss erst alles expandiert werden, damit eine einzelne Datei entnommen werden kann.

Das Skript, das die Zeiten erzeugt, kann in §\ref{listing:compression} gefunden werden.


\subsection{Verteiltes Arbeiten}

Die Dateien auf den zwei verschiedenen Rechnern, die allerdings ihr Heimatverzeichnis teilen, ist fast gleich, bis auf die Datei, die auf dem anderen Rechner schon erstellt worden ist.

\begin{lstlisting}[caption=Unterschied zwischen Ordnerinhalten]
--- ls-lR.host1 2011-10-30 14:43:46.031286114 +0100
+++ ls-lR.host2 2011-10-30 14:43:49.275286307 +0100
@@ -2 +2 @@
-insgesamt 156
+insgesamt 184
@@ -9 +9,2 @@
--rw-r--r-- 1 ueding studis      0 30. Okt 2011  ls-lR.host1
+-rw-r--r-- 1 ueding studis  24614 30. Okt 2011  ls-lR.host1
+-rw-r--r-- 1 ueding studis      0 30. Okt 2011  ls-lR.host2
\end{lstlisting}

Die Dateien sind zwar direkt angelegt, weil bash sie öffnet, allerdings haben sie noch keine Größe. Erst nach dem Durchlauf ist die Datei da. Zwischen Physik und Astro CIP-Pool sind natürlich alle Dateien anders, weil es komplett verschiedene Ordner sind. Nur Dateien wie meine \texttt{.bashrc} sind beispielsweise auf beiden Seiten vorhanden und haben die gleiche Größe, jedoch unterscheidet sich das Änderungsdatum.


\subsection{Shell - Skript}

\lstset{language=bash}
\lstinputlisting[caption=farben.sh]{../Uebung_03/farben.sh}

\lstinputlisting[caption=Ausgabe von farben.sh]{../Uebung_03/farben.sh.out}


\paragraph{Zahlen}

Für die Zahlen kann man entweder \texttt{{1..3}} benutzen, oder eine C-artige for-Schleife benutzen. Die Syntax, die auf dem Übungszettel gibt es nicht, ich weiß nicht, wie Sie die Ausgabe damit erzeugt haben.

\lstset{language=bash}
\lstinputlisting[caption=zahlen.sh]{../Uebung_03/zahlen.sh}

\lstinputlisting[caption=Ausgabe von zahlen.sh]{../Uebung_03/zahlen.sh.out}

Ein Beispiel für die \texttt{{1..3}} finden Sie in Abschnitt §\ref{listing:zahlen2}

Soll von 2 bis 20 gezählt werden und der Vorname ausgegeben werden, wenn der Zähler auf 10 steht, sieht das Skript so aus:


\lstset{language=bash}
\lstinputlisting[caption=zahlen\_name.sh]{../Uebung_03/zahlen_name.sh}

\lstinputlisting[caption=Ausgabe von zahlen\_name.sh]{../Uebung_03/zahlen_name.sh.out}


\subsection{Analyse von Pipelines}

Der Befehl \verb#{find /uebung_03 -type f -exec du -k {} \;| sort -n -r# iteriert durch das Verzeichnis \verb#uebung_03# und dessen Unterverzeichnisse, sucht Einträge heraus, die Dateien sind (und keine Ordner, Links, Fifos, …). Auf jede dieser Dateien wird der Befehl \texttt{du -k} ausgeführt. Man erhält eine Liste mit Dateigrößen in kiB. Diese Liste wird dann numerisch und rückwärts sortiert, also die größten Dateien nach vorne.

\paragraph{Teilaufgabe a}
In dieser Aufgabe ist wahrscheinlich ein \verb#ps aux | grep ueding# gefragt. Dies ist allerdings gefährlich, falls jemand anderes ein Programm ausführt, das meinen Namen im Namen hat, oder jemand anders so heißt wie ich, nur mit einer 2 dahinter. Daher wäre es mit einer genauen Suche nach der Position in der Zeile etwas sicherer. Allerdings kann man auch einfach das \texttt{a} weglassen und erhält direkt eine Liste mit seinen eigenen Prozessen.

\begin{lstlisting}[caption=Einschänkung des Suchbereichs]
ps aux | grep '^ueding\ s '
\end{lstlisting}

\paragraph{Teilaufgabe b}
Für das Sortieren hat \texttt{ps} auch eine entsprechende Option: \texttt{O+p}. So lässt sich mit \texttt{ps ux O+p} direkt nach Prozess-ID sortieren.

\paragraph{Teilaufgabe c}
Mit \verb#ps ux O+p > myprocesses.txt# lässt sich die entsprechnde Datei \url{../Uebung_03/myprocesses.txt} erzeugen. Wenn man mag, kann man natürlich auch diesen Code benutzen:
\begin{lstlisting}[caption=verkettete Pipes]
ps aux | grep ueding | sort -n > myprocesses.txt
\end{lstlisting}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                Ende Inhalte                                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\newpage

\begin{appendix}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%                                Code Listings                                %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\section{Code Listings}
\subsection{Kompressionsvergleich}
\label{listing:compression}
\lstset{language=bash}
\lstinputlisting[caption=compare.sh, language=bash]{/home/mu/Branches/compression_comparison/compare.sh}

\subsection{Alternative Zählschleife}
\label{listing:zahlen2}

\lstset{language=bash}
\lstinputlisting[caption=zahlen2.sh]{../Uebung_03/zahlen2.sh}

\lstinputlisting[caption=Ausgabe von zahlen2.sh]{../Uebung_03/zahlen2.sh.out}
\end{appendix}

\end{document}
