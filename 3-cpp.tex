% Copyright (c) 2011 Martin Ueding <dev@martin-ueding.de>

\part{C++}

\chapter{Übung 6}

\section{Das \gqq{Hello, World!}-Programm}

Dies ist das einfache \gqq{Hello, World!}-Programm (Listing \ref{code:hello}), das Kerningham und Ritchie zum Einstieg empfehlen um seine Entwicklungsumgebung entsprechend einzurichten.

\code[c++]{Uebung_06/hello/hello.cpp}{hello.cpp}{code:hello}

Um das ganze zu kompilieren braucht man einen C++-Compiler, in diesem Fall ist es \texttt{g++}. Man kann aber genauso gut \texttt{MSVC++} benutzen.

Ich möchte nicht immer den Compilerbefehl erneut eintippen\footnote{Wobei in Bash der letzte Kompiliervorgang mit \texttt{!g++} noch recht schnell zu wiederholen ist.}, so dass ich hier eine Makefile benutze um das Programm mit einem einfachen \texttt{make} kompilieren zu können. Außerdem wird hier auch direkt die Ausgabe des Programms in eine Datei gefügt, die dann wiederum in dieses \LaTeX\ Dokument eingefügt wird. Somit sind die Ausgaben, die hier enthalten sind tatsächlich von den Programmen erzeugt worden.


Die Ausgabe des Programms \ref{code:hello} ist in Listing \ref{code:hello.out} zu sehen.

\code{Uebung_06/hello/hello.out}{Ausgabe von hello}{code:hello.out}

Die Optionen \texttt{-Wall und --pedantic} zeigen deutlich mehr Unstimmigkeiten im Code auf und sind damit zu empfehlen. Das im Beispiel benutzte \texttt{int a;}, das allerdings nie verwendet wird, ist meistens ein Fehler und man hat an einer anderen Stelle nicht \texttt{a}, sondern versehentlich eine andere Zahl benutzt.

\section{Äthiopische Multiplikation}
\label{section:ethiopian}

Das Program (Listing \ref{code:ethiopian}) habe ich aus dem Skript kopiert und entsprechend wieder mit Makefile versehen. Damit es von der Makefile allerdings nicht-interaktiv kompiliert werden kann, übernehme ich die Eingabezahlen von der Kommandozeile.

\code[c++]{Uebung_06/ethiopian/ethiopian.cpp}{ethiopian.cpp}{code:ethiopian}

Die Ausgabe für $14 \cdot 36$ ist in Listing \ref{code:ethiopian.out} gezeigt.

\code{Uebung_06/ethiopian/ethiopian.out}{Ausgabe von ethiopian}{code:ethiopian.out}

Möchte man nun eine Art Multiplikationstabelle von eins bis zehn erhalten, muss man zwei ineinander geschachtelte Schleifen bauen. \texttt{a} und \texttt{b} können nicht als Schleifenindizes verwendet werden, da sie vom Algorithmus verwendet werden. Entweder kapselt man den Algorithmus in eine Funktion, oder man benutzt einfach andere Variablen. Das geänderte Programm ist in Listing \ref{code:ethiopian-ng} zu sehen. Die Ausgabe ist in Listing \ref{code:ethiopian-ng.short.out}) gezeigt.

\code[c++]{Uebung_06/ethiopian-ng/ethiopian.cpp}{ethiopian-ng.cpp}{code:ethiopian-ng}

\code{Uebung_06/ethiopian-ng/ethiopian.out}{Ausgabe von ethiopian-ng}{code:ethiopian-ng.short.out}

Möchte man alle Multiplikationen haben, lässt man die Indizes von 1 bis 10 laufen. Um kommutativ äquivalente Rechnungen zu unterdrücken, lässt man den inneren Index beim äußeren Index starten.

\section{Heron}

Der Algorithmus ist recht einfach umzusetzen, man benötigt die Formel, die auf dem Übungsblatt angegeben ist.

\begin{equation}
x_{n+1}=\frac{x_n+\frac{a}{x_n}}{2}
\end{equation}

Dabei ist $a$ die Zahl, von der die Wurzel bestimmt werden soll. Diese Formel braucht noch ein $x_0$, damit sie funktioniert. Hier kann man einfach jede beliebige Zahl benutzen. Allerdings ist $x_0=a$ keine allzu schlechte Wahl.

Eine Abbruchbedingung kann verschieden aussehen. Man kann nach einer gewissen Anzahl von Iterationen abbrechen. Ich habe mich dafür entschieden, abzubrechen, sobald sich die Zahl nur noch wenig verändert. Dazu muss man sich merken, welchen Wert die Zahl vorher hatte, um vergleichen zu können.

Das ganze Programm könnte man rekursiv implementieren, allerdings spricht hier nichts gegen eine iterative Variante, daher habe ich mich für letzteres entschieden. Mein Programm ist in Listing \ref{code:heron} zu sehen.

\code[c++]{Uebung_06/heron/heron.cpp}{heron.cpp}{code:heron}

Ich lasse $\sqrt{2} \approx 1.41421356237309504880168872421$\footnote{Mit \texttt{N[Sqrt[2], 30]} in Mathematica berechnet.} berechnen, die Ausgabe ist in Listing \ref{code:heron.out} zu sehen. Man kann sehen, dass das Programm schnell zu einem brauchbaren Ergebnis kommt, der Algorithmus also leistungsfähig ist.

\code{Uebung_06/heron/heron.out}{Ausgabe von heron}{code:heron.out}

\chapter{Übung 7}

Mein Programm, dass die Daten einließt und wieder speichert ist in Listing \ref{code:arrays.cpp} zu finden. Die Aufgabe ist in Listing \ref{code:arrays.out}.

\code[c++]{Uebung_07/arrays/arrays.cpp}{arrays.cpp}{code:arrays.cpp}
\code{Uebung_07/arrays/out.dat}{Ausgabe von arrays}{code:arrays.out}

\section{Versuchsergebnisse}

Dies ist das Programm, das die Spannungs- und Stromdaten einließt und entsprechend auswertet. Die Widerstandstabelle ist in Listing \ref{code:bericht.out}, die statistischen Größen in Listing \ref{code:means.dat}.

\code[c++]{Uebung_07/bericht/bericht.cpp}{bericht.cpp}{code:bericht.cpp}
\code{Uebung_07/bericht/out.dat}{Ausgabedatei von bericht}{code:bericht.out}
\code{Uebung_07/bericht/means.dat}{Ausgabe von bericht}{code:means.dat}

\chapter{Übung 8}

\section{Strings}

\lstinputlisting[caption=String main.cpp, label=code:string-main.cpp, language=c++]{Uebung_08/Strings/main.cpp}

\section{Klassen}

\lstinputlisting[caption=String main.cpp, label=code:student-main.cpp, language=c++]{Uebung_08/Student/main.cpp}
\lstinputlisting[caption=String student.cpp, label=code:student-student.cpp, language=c++]{Uebung_08/Student/student.cpp}
\lstinputlisting[caption=String student.h, label=code:student-student.h, language=c++]{Uebung_08/Student/student.h}

\section{Berichtsaufgabe}

\lstinputlisting[caption=Consolidator main.cpp, label=code:consolidator-main.cpp, language=c++]{Uebung_08/Consolidator/main.cpp}

\chapter{Übung 9}

\section{Einfache Zeiger}

Die Programmzeile wird die Zahl 5 und die Adresse von i, die auf dem Aufgabenzettel angegeben ist, ausgeben.

Die Ausgabe von \verb#&i# ist die Speicheradresse, \verb#*(&i)# wird die Zahl 5 ausgeben.

\section{Überprüfungsaufgabe}

Fast alles davon geht. Nur kann man keinem Array einen Pointer zuweisen. Das Array ist zwar ein Pointer, allerdings ein Speziallfall davon. Klassische Polymorphie.

Bei der zweiten Teilaufgabe sollte der Compiler nichts davon akzeptieren, da \texttt{int} und \texttt{int*} unterschiedliche Datentypen sind. Da es allerdings nur Zahlen sind, kann man trotzdem irgendwie mit ihnen rechnen.

Auf den Pointer kann man anscheinend ints addieren, allerdings kann man dem int fast kein Pointerwerte zuweisen, nur per Multiplikation. Nur eine Differenz ist möglich. Das ist interessant. Letztlich ist nur eine Differenz interessant, da dies die Lange eines Arrays darstellen kann.

\section{Zeiger und Funktionen}

Die Lösung ist in Listing \ref{code:swap} gezeigt. In der Übung schreiben Sie \texttt{int **}, allerdings weiß ich nicht so recht, wo ich das dann einbauen soll. Die Ausgabe ist in \ref{code:swap.out} gezeigt.

\code[c++]{Uebung_09/swap/swap.cpp}{Swap}{code:swap}
\code{Uebung_09/swap/swap.out}{Swap}{code:swap.out}
