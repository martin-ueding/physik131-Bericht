% Copyright (c) 2011 Martin Ueding <dev@martin-ueding.de>

\part{Linux}

\section{Befehle in der Konsole}
\label{commands}

\subsection{Benutzerverwaltung und -rechte}
\begin{itemize}
\dd{chmod}{Ändert Dateirechte.}
\dd{hostname}{Gibt den Rechnernamen aus.}
\dd{last}{Letzte Anmeldungen aller Benutzer.}
\dd{ps}{Gibt eine Prozessliste aus. Dieses Programm ist nicht interaktiv und eignet sich beispielsweise für Logdateien.}
\dd{top}{Vorgänger von \texttt{htop}, eine interaktive Prozessverwaltung.}
\dd{uname}{Gibt Kernelversion, Rechnername, ..., aus.}
\dd{uptime}{Zeigt, wie viele Nächte der Rechner am Stück durchgemacht hat.}
\dd{whoami}{Gibt den eigenen Benutzernamen aus.}
\dd{w}{Wie \texttt{who}, nur ausführlicher.}
\end{itemize}

\subsection{Dateibehandlung}
\begin{itemize}
\dd{bzip2}{Komprimiert eine Datei.}
\dd{cd}{Wechselt in das angegebene Verzeichnis. Dabei ist \texttt{..} das übergeordnete Verzeichnis. Wird als Verzeichnis \texttt{-} angegeben, kommt man in das vorherige Verzeichnis. \texttt{cd} ohne Verzeichnis wechselt in das Heimatverzeichnis\footnote{Meistens \texttt{/home/<benutzername>}.}.}
\dd{cp}{Kopiert Dateien.}
\dd{df}{Listet die Dateisysteme mit Belegungsangabe.}
\dd{du}{Zeigt die Größe von Dateien auf dem Datenträger an. Diese muss nicht unbedingt mit der Größe überstimmen, die \texttt{ls} anzeigt, da die Dateien in Blöcken organisiert sind.}
\dd{find}{Führt eine Dateisystemtraverse nach speziellen Suchvorgaben durch und zeigt standardmäßig alle Dateien und Ordner an.}
\dd{gzip}{Komprimiert eine Datei.}
\dd{ls}{Listet den Inhalt des angegebenen oder aktuellen Verzeichnisses auf. Dabei werden auch Informationen über Zugriffsrechte und Eigentümer, Größe und Änderungsdatum angezeigt, gibt man \texttt{-l} an.}
\dd{mkdir}{Erstellt ein Verzeichnis.}
\dd{mv}{Verschiebt Dateien, Umbenennen ist ein Spezialfall.}
\dd{rmdir}{Löscht leere Verzeichnisse.}
\dd{rm}{Löscht Dateien.}
\dd{scp}{Kopiert über SSH.}
\dd{tar}{Erstellt ein Archiv mehrerer Dateien. Mit \texttt{tar -xzf archiv.tar.gt datei1 datei2…}\cite{man-tar} erstellt man direkt ein komprimiertes Archiv mehrerer Dateien.}
\dd{touch}{Setzt das Änderungsdatum einer Datei auf den aktuellen Zeitpunkt und erzeugt die Datei, falls sie nicht existiert.}
\end{itemize}

\subsection{Informationen zu Programmen}
\begin{itemize}
\dd{apropos}{Unscharfe Suche nach Befehlen.}
\dd{man}{Zeigt Handbücher zu Programmen an.}
\dd{whatis}{Zeigt die erste Zeile des Handbuchs an.}
\end{itemize}

\subsection{Textdateien}
\begin{itemize}
\dd{diff}{Vergleicht Dateien miteinander.}
\dd{emacs}{Texteditor.}
\dd{grep}{Filtert Zeilen nach einem Suchmuster.}
\dd{head}{Zeigt die ersten n Zeilen einer Datei an.}
\dd{less}{Zeigt eine Datei an und erlaubt scrollen, suchen, springen. Es können viele Befehle aus \texttt{vi} (gg, G, /, j, k) benutzt werden.}
\dd{pdflatex}{Übersetzt ein \LaTeX\ Dokument in ein PDF.}
\dd{sort}{Sortiert Zeilen.}
\dd{tail}{Gegenstück zu \texttt{head}.}
\dd{uniq}{Spezialfall von \texttt{sort -u}}
\dd{vim}{Texteditor für Programmierer.}
\dd{wc}{Zählt Wörter, Zeilen, Buchstaben.}
\end{itemize}

\subsection{Bash built-ins}
\begin{itemize}
\dd{clear}{Fügt leere Zeilen ein, bis der Bildschirm leer ist.}
\dd{set}{Zeigt das Environment der Shell an.}
\dd{echo}{Gibt Text aus.}
\dd{history}{Zeigt die letzten Kommandos an.}
\end{itemize}

\subsection{Diverses}
\begin{itemize}
\dd{bc}{Einfacher Taschenrechner. Man sollte in der Bash allerdings nicht mit \texttt{\$(echo 5+4 | bc)} rechnen, sondern die neuen, von C übernommenen Funktionen zum direkten Rechnen, \texttt{\$((5+4))}, benutzen.}
\dd{blkid}{Zeigt die UUID der Partitionen an.}
\dd{e2label}{Zeigt und vergibt Partitionslabel.}
\dd{ssh}{Öffnete eine Shell auf einem anderen Computer.}
\dd{wget}{Lädt Dateien per http oder ftp.}
\dd{cal}{Zeigt einen Kalendermonat an.}
\dd{date}{Zeigt das Datum in einem gewählten Format an.}
\dd{gv}{Zeigt eine PDF oder PS Datei an. Normalerweise würde man okular (KDE) oder evince (Gnome) benutzen.}
\end{itemize}

\section{absoluter und relativer Pfad}

Ein absoluter Pfad beginnt immer mit einem \texttt{/}, wie beispielsweise \\ \texttt{/home/mu/Dokumente/Studium/EDV/Bericht} oder \texttt{/dev/null}. Ein relativer Pfad bezieht sich immer auf ein aktuelles Arbeitsverzeichnis. Beispielsweise beschreibt \texttt{datei.tex} die Datei \texttt{/tmp/datei.txt}, falls der Benutzer gerade \texttt{/tmp} als Arbeitsverzeichnis hat. Pfade können auch \texttt{..} enthalten, dies bezeichnet das übergeordnete Verzeichnis. Ist man gerade in \texttt{/etc/apache2}, so kann man mit \texttt{../passwd} auf die zentrale Passwortdatei verweisen.

Gemeinerweise können absolute Pfade auch \texttt{..} enthalten, so wäre \\
\texttt{/etc/apache2/../passwd} ein legaler Pfad, sinnvoll ist es in vielen Fällen allerdings nicht.

\section{Analyse von Pipelines}

Der Befehl \verb#find /uebung_03 -type f -exec du -k {} \;| sort -n -r#\ iteriert durch das Verzeichnis \verb#uebung_03# und dessen Unterverzeichnisse, sucht Einträge heraus, die Dateien sind (und keine Ordner, Links, Fifos, …). Auf jede dieser Dateien wird der Befehl \texttt{du -k} ausgeführt. Man erhält eine Liste mit Dateigrößen in kiB. Diese Liste wird dann numerisch und rückwärts sortiert, also die größten Dateien nach vorne.

\subsection{Teilaufgabe a}
In dieser Aufgabe ist wahrscheinlich ein \verb#ps aux | grep ueding# gefragt. Dies ist allerdings gefährlich, falls jemand anderes ein Programm ausführt, das meinen Namen im Namen hat, oder jemand anders so heißt wie ich, nur mit einer 2 dahinter. Außerdem wird \texttt{grep} auch sich selbst in der Ausgabe von \texttt{ps} finden, weil mein Name auch Teil des Kommandos ist und somit dieser wieder in der Prozessliste auftaucht. Daher wäre es mit einer genauen Suche nach der Position in der Zeile etwas sicherer (Listing \ref{code:psauxgrep-beginning}). So hätte man beide Probleme aus dem Weg.

Allerdings kann man auch einfach das \texttt{a} weglassen und erhält direkt eine Liste mit seinen eigenen Prozessen und vermeidet an dieser Stelle die Benutzung von \texttt{grep} komplett.

\code[bash]{Uebung_03/psauxgrep-beginning.sh}{Einschänkung des Suchbereichs}{code:psauxgrep-beginning}

\subsection{Teilaufgabe b}
Für das Sortieren hat \texttt{ps} auch eine entsprechende Option: \texttt{O+p}. So lässt sich mit \texttt{ps ux O+p} direkt nach Prozess-ID sortieren.

\subsection{Teilaufgabe c}
Mit \verb#ps ux O+p > myprocesses.txt# lässt sich die entsprechende Datei (Listing \ref{code:myprocesses}) erzeugen.

\code{Uebung_03/myprocesses.txt}{myprocesses.txt}{code:myprocesses}


Wenn man mag, kann man natürlich auch den Code aus Listing \ref{code:chain-pipe} benutzen.

\code[bash]{Uebung_03/chain-pipe.sh}{verkettete Pipes}{code:chain-pipe}

\section{weitere Linux Befehle}

\subsection{Super GAU}

Der Unterschied zwischen \verb#rm -rf ./uebung/*# und \verb#rm -rf ./uebung/ *# ist, dass bei erstem alle Dateien und Unterordner des Verzeichnis \texttt{uebung} ohne Nachfrage gelöscht werden, im zweiten wird der Ordner selbst ebenfalls rekursiv gelöscht und alle anderen Dateien ebenfalls gelöscht. Das einzige, das dann noch bleibt, sind versteckte Dateien, deren Namen mit einem Punkt beginnt.

\subsection{frage.txt}

Der erste Befehl kopiert die Datei \texttt{/home/meinname/uebung/frage.txt} nach \texttt{/home/meinname/uebung}. Dies klappt allerdings nicht, weil es schon ein Verzeichnis mit dem gleichen Namen gibt.

Im zweiten Kommanto wird die Datei nach \texttt{/home/meinname/uebung/frage.txt} kopiert. Die Datei wird mit sich selbst überschrieben. Dies wird allerdings verhindert, das klappt also auch nicht.

Der dritte Befehl wird alle Dateien nach \texttt{/home/meinname/uebung} kopieren. Es sollte eine Fehlermeldung geben, die \gqq{keine reguläre Datei} lautet, da man schlecht mehrere Dateien in eine kopieren kann.

Der vierte Befehl kopiert alle Dateien in den Ordner selbst. Da die Dateien mit sich selbst überschrieben werden würden, schlägt das fehl.

\paragraph*{Verzeichnis existiert nicht} Falls das Verzeichnis nicht existiert, kann die Datei \texttt{frage.txt} nicht existieren, womit die ersten Beiden Befehle daran scheitern werden, dass es die Datei nicht gibt.

Das zweite Kommando könnte sich auch noch darüber beschweren, dass es das Zielverzeichnis nicht gibt.

Die letzten beiden werden daran scheitern, dass die Datei \texttt{uebung/*} nicht existiert. Falls sie in Bash den Nullglob aktiviert haben, wird moniert, dass kein Ziel angegeben worden ist.

\paragraph*{im Verzeichnis}

Falls man im Verzeichnis ist, so wird der erste Befehl im dortigen Verzeichnis eine neue Datei \texttt{uebung} erzeugen -- kein Problem.

Der zweite Befehl wird wegen das wohl nicht vorhandene Verzeichnis scheitern.

Befehl drei wird nur funktionieren, wenn es exakt eine Datei gibt. Da mehrere Dateien drin sind, klappt es nicht.

Bei dem vierten Befehl würden die ganzen Dateien in den Unterordner \texttt{uebung} kopiert. Da es diesen nicht gibt, schlägt es fehl.

\subsection{Backup}

Um alle Dateien zu Packen, würde ich \verb#tar -xzf backup.tar.gz .??* *# ausführen. Dies packt alle sichtbaren und unsichtbaren Dateien, allerdings nicht die impliziten \texttt{.} und \texttt{..} ein.

Das ganze bekommt man in den anderen Pool mit einem \verb#scp backup.tar ciptux:#, falls man vorher in der \texttt{.ssh/config} entsprechend den kompletten Hostnamen des Servers eingetragen hat.

\subsection{Dateirechte}

Im Allgemeinen werden Zugriffsrechte über die Werkzeuge \texttt{chmod} und \texttt{chown} sowie \texttt{chgrp} geändert.

Wenn ein Verzeichnis nicht leer ist, kann es von \texttt{rmdir} nicht gelöscht werden. Man kann es vorher mit \texttt{rm uebung02/*} leeren, wobei man dort bei Unterverzeichnissen das gleiche Problem hat. Die einfache Variante ist es, einfach \texttt{rm -rf uebung02} zu benutzen.

Wenn man unbedingt dem Kommilitonen Schreibrechte gewähren möchte, müssen die Rechte auf \texttt{664} oder \texttt{660} stehen. Ich würde lieber die Rechte auf \texttt{640} stellen und meinen Kommilitonen bitten seine Änderungen auf ähnliche Weise in seinem Heimatverzeichnis bereitzustellen. Dann kann ich mit \texttt{diff -u meinedatei seinedatei} schauen, was er verändert hat und es mit \texttt{cp seinedatei meinedatei} übernehmen.
